name: Docker é•œåƒæ„å»ºä¸å‘å¸ƒ

on:
  push:
    branches: [ main ]
    tags:
      - 'v*.*.*'
    paths-ignore:
      - '**.md'
      - 'LICENSE'
      - '.gitignore'
      - '.claude/**'
  workflow_dispatch:
  schedule:
    # æ¯å‘¨æ—¥å‡Œæ™¨ 2 ç‚¹æ¸…ç†ç¼“å­˜
    - cron: '0 2 * * 0'

env:
  REGISTRY: docker.io
  IMAGE_NAME: 782042369/top1000-iyuu
  # æœ€å¤§ç¼“å­˜æ•°é‡ï¼ˆä¿ç•™æœ€æ–°çš„ N ä¸ªç¼“å­˜ï¼‰
  MAX_CACHE_COUNT: 5

jobs:
  build-and-push:
    name: æ„å»ºå¹¶æ¨é€ Docker é•œåƒ
    runs-on: ubuntu-latest
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true
    permissions:
      contents: read
      packages: write
      actions: write

    steps:
      - name: ğŸ“¥ æ£€å‡ºä»£ç 
        uses: actions/checkout@v4

      - name: ğŸ”§ è®¾ç½® Docker Buildxï¼ˆä»… AMD64ï¼‰
        uses: docker/setup-buildx-action@v3
        with:
          # å¯ç”¨æ„å»ºç¼“å­˜
          driver-opts: |
            image=moby/buildkit:latest
            network=host

      - name: ğŸ” ç™»å½• Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERUSERNAME }}
          password: ${{ secrets.DOCKERPASSWORD }}

      - name: ğŸ“‹ æå–é•œåƒå…ƒæ•°æ®
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest,enable={{is_default_branch}}
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-,format=short
          labels: |
            org.opencontainers.image.title=Top1000 PTèµ„æºè¿½è¸ªç³»ç»Ÿ
            org.opencontainers.image.description=PTç«™ç‚¹èµ„æºè¿½è¸ªç³»ç»Ÿï¼Œæç®€æ¶æ„ï¼ŒDockeré•œåƒä»…4.5-5MB
            org.opencontainers.image.vendor=782042369
            org.opencontainers.image.source=${{ github.repositoryUrl }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
            org.opencontainers.image.licenses=MIT

      - name: ğŸ—ï¸ æ„å»ºå¹¶æ¨é€é•œåƒï¼ˆAMD64ï¼‰
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          # ç¼“å­˜é…ç½®ï¼šä¼˜åŒ–æ„å»ºé€Ÿåº¦
          cache-from: |
            type=gha
            type=local,src=/tmp/.buildx-cache
          cache-to: |
            type=gha,mode=max
            type=local,dest=/tmp/.buildx-cache-new,mode=max
          # æ„å»ºå‚æ•°
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            GOMODCACHE=/go/pkg/mod
          # ç¦ç”¨ä¸å¿…è¦çš„åŠŸèƒ½
          provenance: false
          sbom: false

      # ç§»åŠ¨ç¼“å­˜ï¼ˆé¿å…ç¼“å­˜æ— é™å¢é•¿ï¼‰
      - name: ğŸ”„ ä¼˜åŒ–æœ¬åœ°ç¼“å­˜
        run: |
          echo "ğŸ”§ ä¼˜åŒ–æ„å»ºç¼“å­˜..."
          if [ -d /tmp/.buildx-cache ]; then
            echo "ğŸ“Š å½“å‰ç¼“å­˜å¤§å°ï¼š"
            du -sh /tmp/.buildx-cache
            # å¤‡ä»½æ—§ç¼“å­˜
            rm -rf /tmp/.buildx-cache-backup || true
            mv /tmp/.buildx-cache /tmp/.buildx-cache-backup || true
          fi
          # ä½¿ç”¨æ–°ç¼“å­˜
          if [ -d /tmp/.buildx-cache-new ]; then
            mv /tmp/.buildx-cache-new /tmp/.buildx-cache || true
          fi
          # æ¸…ç†å¤‡ä»½
          rm -rf /tmp/.buildx-cache-backup || true
          echo "âœ… ç¼“å­˜ä¼˜åŒ–å®Œæˆ"

      - name: ğŸ“Š æ˜¾ç¤ºé•œåƒä¿¡æ¯
        run: |
          echo "ğŸ“¦ é•œåƒæ ‡ç­¾: ${{ steps.meta.outputs.tags }}"
          echo "ğŸ”‘ é•œåƒæ‘˜è¦: ${{ steps.build.outputs.digest }}"
          echo "â° æ„å»ºæ—¶é—´: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"

      - name: ğŸ§¹ æ¸…ç†æ—§ç¼“å­˜
        if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
        uses: actions/github-script@v7
        with:
          script: |
            const maxCacheCount = ${{ env.MAX_CACHE_COUNT }};

            console.log(`ğŸ§¹ å¼€å§‹æ¸…ç†ç¼“å­˜...`);
            console.log(`ğŸ”¢ æœ€å¤§ä¿ç•™æ•°é‡ï¼š${maxCacheCount} ä¸ª`);

            let page = 1;
            let allCaches = [];

            // æ”¶é›†æ‰€æœ‰ç¼“å­˜
            while (true) {
              const caches = await github.rest.actions.getActionsCacheList({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100,
                page: page,
              });

              if (!caches.data.actions_caches || caches.data.actions_caches.length === 0) {
                break;
              }

              allCaches = allCaches.concat(caches.data.actions_caches);

              if (caches.data.actions_caches.length < 100) {
                break;
              }

              page++;
            }

            console.log(`ğŸ“¦ æ€»ç¼“å­˜æ•°é‡ï¼š${allCaches.length}`);

            // æŒ‰æœ€åä½¿ç”¨æ—¶é—´æ’åºï¼ˆæœ€æ–°çš„åœ¨å‰ï¼‰
            allCaches.sort((a, b) => new Date(b.last_accessed_at) - new Date(a.last_accessed_at));

            // åªä¿ç•™æœ€æ–°çš„ maxCacheCount ä¸ªç¼“å­˜
            const deletedCount = Math.max(0, allCaches.length - maxCacheCount);

            if (deletedCount > 0) {
              console.log(`ğŸ—‘ï¸  å°†åˆ é™¤ ${deletedCount} ä¸ªæ—§ç¼“å­˜...`);

              for (let i = maxCacheCount; i < allCaches.length; i++) {
                const cache = allCaches[i];
                console.log(`ğŸ—‘ï¸  åˆ é™¤ç¼“å­˜: ${cache.key}`);
                console.log(`   æœ€åä½¿ç”¨: ${cache.last_accessed_at}`);
                console.log(`   å¤§å°: ${cache.size_in_bytes} bytes`);

                await github.rest.actions.deleteActionsCacheById({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  cache_id: cache.id,
                });
              }

              // è®¡ç®—é‡Šæ”¾çš„ç©ºé—´
              const deletedCaches = allCaches.slice(maxCacheCount);
              const deletedSize = deletedCaches.reduce((sum, cache) => sum + (cache.size_in_bytes || 0), 0);
              console.log(`ğŸ’¾ é‡Šæ”¾ç©ºé—´: ${(deletedSize / 1024 / 1024).toFixed(2)} MB`);
            } else {
              console.log(`âœ… ç¼“å­˜æ•°é‡åœ¨é™åˆ¶èŒƒå›´å†…ï¼Œæ— éœ€æ¸…ç†`);
            }

            console.log(`\nâœ¨ æ¸…ç†å®Œæˆï¼`);
            console.log(`ğŸ—‘ï¸  åˆ é™¤æ•°é‡: ${deletedCount} ä¸ª`);
            console.log(`âœ… ä¿ç•™æ•°é‡: ${Math.min(allCaches.length, maxCacheCount)} ä¸ª`);
